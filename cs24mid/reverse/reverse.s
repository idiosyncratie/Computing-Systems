.globl reverse_list           # Ignore everything beginning with a "." 
.text
    .align 4

reverse_list: 
    pushl %ebp              # Push old base pointer. 
    movl %esp,%ebp          # Current stack is new base. 
    mov    8(%ebp), %esi         # linked list - do validation checks
    mov    (%esi), %ebx          # head
    test    %ebx, %ebx           # if not null, continues 
    je reverse_ret
    mov    4(%esi), %eax       # tail
    test   %eax, %eax          # if not null, continue 
    je reverse_ret
    mov    %ebx, %ecx       # take note of head
    cmp    %eax, %ebx       # 1 element
    je reverse_ret

    .align 4                # This is generated by the compiler to align 
                            # code so that the CPU can process it better.

push_list:      # 2 or more elements: push the elements
    push    %ebx
iterate_push: 
    mov     4(%ebx), %ebx
    cmp     %ebx, %eax
    jne     push_list

pop_list:      # pop elements and reverse arrows
# currently: ecx = head, eax = tail
    pop    %edx         # get the last node on stack
    mov   %edx, 4(%eax)  # point tail
    cmp    %edx, %ecx   # check if at beginning
    je     reverse_ret

iterate_pop: 
    pop    %ebx         # get next node on stack
    mov   %ebx, 4(%edx)  # point tail
    cmp    %ebx, %ecx   # check if at beginning
    je    done
pop_continue:
    mov  %ebx, %edx   # iterate
    jmp  iterate_pop

done:        # reset head and tail in linkedlist
    mov  %eax, (%esi)      # new head
    mov  %ebx, 4(%esi)         # new tail
    movl  $0, 4(%ebx)       # set head->next to Null

reverse_ret:                # return the reversed list
    movl %ebp, %esp     # Pop local stack. 
    popl %ebp          # Pop old base of frame. 
    ret
